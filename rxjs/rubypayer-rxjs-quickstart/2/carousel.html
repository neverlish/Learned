<html>
<head>
  <style>
    .view {
      overflow: hidden;
    }

    .view .container {
      white-space: nowrap;
      padding: 0px;
      list-style: none;
      font-size: 0;
    }

    .view .panel {
      width: 100%;
      min-height: 200px;
      display: inline-block;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.2.2/rxjs.umd.min.js"></script>
</head>
<body>
  <div id="carousel" class="view">
    <ul class="container">
      <li class="panel" style="background-color:lightgreen">
      </li>
      <li class="panel" style="background-color:lightpink">
      </li>
      <li class="panel" style="background-color:royalblue">
      </li>
      <li class="panel" style="background-color:darkred">
      </li>
    </ul>
  </div>

  <script>
    const { fromEvent, merge, animationFrameScheduler, interval, concat, of } = rxjs;
    const { mergeMap, takeUntil, map, switchMap, first, startWith, withLatestFrom, tap, share, scan, takeWhile } = rxjs.operators;

    const $view = document.getElementById('carousel');
    const $container = document.querySelector('.container');
    const PANEL_COUNT = $container.querySelectorAll('.panel').length;

    const SUPPORT_TOUCH = 'ontouchstart' in window;
    const EVENTS = {
      start: SUPPORT_TOUCH ? 'touchstart' : 'mousedown',
      move: SUPPORT_TOUCH ? 'touchmove' : 'mousemove',
      end: SUPPORT_TOUCH ? 'touchend' : 'mouseup'
    };

    function toPos(obj$) {
      return obj$
        .pipe(
          map(v => SUPPORT_TOUCH ? event.changedTouches[0].pageX : event.pageX)
        );
    }

    const THRESHOLD = 30;
    const DURATION = 300;
    const from = 100;
    const to = 500;
    const start$ = fromEvent($view, EVENTS.start).pipe(toPos);
    const move$ = fromEvent($view, EVENTS.move).pipe(toPos);
    const end$ = fromEvent($view, EVENTS.end);

    const scheduler = animationFrameScheduler;
    const start = scheduler.now();
    const interval$ = interval(0, scheduler)
      .pipe(
        map(() => (scheduler.now() - start) / DURATION),
        takeWhile(rate => rate < 1)
      );
    const animation$ = concat(interval$, of(1))
      .pipe(
        map(rate => from + (to - from) * rate)
      );
    animation$.subscribe(rate => console.log('animation$', rate));
    /*
    animation$ 112
    animation$ 116
    animation$ 117.33333333333334
    animation$ 120
    animation$ 124
    animation$ 126.66666666666667
    animation$ 146.66666666666666
    animation$ 149.33333333333334
    animation$ 169.33333333333334
    animation$ 172
    animation$ 190.66666666666666
    animation$ 193.33333333333331
    animation$ 213.33333333333331
    animation$ 214.66666666666669
    animation$ 236
    animation$ 240
    animation$ 260
    animation$ 261.3333333333333
    animation$ 281.3333333333333
    animation$ 284
    animation$ 302.6666666666667
    animation$ 304
    animation$ 325.33333333333337
    animation$ 328
    animation$ 348
    animation$ 352
    animation$ 369.3333333333333
    animation$ 373.3333333333333
    animation$ 390.6666666666667
    animation$ 393.3333333333333
    animation$ 414.66666666666663
    animation$ 417.3333333333333
    animation$ 437.33333333333337
    animation$ 441.33333333333337
    animation$ 457.3333333333333
    animation$ 462.66666666666663
    animation$ 480
    animation$ 484
    animation$ 500
    */

    const drag$ = start$.pipe(
      switchMap(start => {
        return move$.pipe(
          map(move => move - start),
          takeUntil(end$)
        );
      }),
      // tap(v => console.log('drag$', v)),
      share(),
      map(distance => ({ distance }))
    );
    
    // drag$.subscribe(distance => console.log("start$와 move$의 차이 값", distance));

    const size$ = fromEvent(window, 'resize')
      .pipe(
        startWith(0),
        map(event => $view.clientWidth)
      );

    const drop$ = drag$.pipe(
      switchMap(drag => {
        return end$.pipe(
          map(event => drag), // drag는 drag$가 전달하는 start$와 end$의 위치 값의 거리
          first()
        );
      }),
      // tap(v => console.log('drop$', v)),
      withLatestFrom(size$, (drag, size) => {
        return { ...drag, size };
      })
    );

    // drop$.subscribe(array => console.log('drop', array));

    const carousel$ = merge(drag$, drop$)
      .pipe(
        scan((store, { distance, size }) => {
          const updateStore = {
            from: -(store.index * store.size) + distance,
          };
          if (size === undefined) { // drag 시점
            updateStore.to = updateStore.from;
          } else { // drop 시점
            let tobeIndex = store.index;
            if (Math.abs(distance) >= THRESHOLD) {
              tobeIndex = distance < 0 ?
                Math.min(tobeIndex + 1, PANEL_COUNT - 1) : 
                Math.max(tobeIndex - 1, 0);
            }
            updateStore.index = tobeIndex;
            updateStore.to = -(tobeIndex * size);
            updateStore.size = size;
          }

          return { ...store, ...updateStore };
        }, {
          from: 0,
          to: 0,
          index: 0,
          size: 0
        })
      );

    function translateX(posX) {
      $container.style.transform = `translate3d(${posX}px, 0, 0)`;
    }
    carousel$.subscribe(store => {
      console.log('캐러셀 데이터', store);
      translateX(store.to);
    });
  </script>
</body>
</html>
